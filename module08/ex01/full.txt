# **************************************************************************** #
#                                                                              #
#                                                         :::      ::::::::    #
#    Makefile                                           :+:      :+:    :+:    #
#                                                     +:+ +:+         +:+      #
#    By: brturcio <brturcio@student.42.fr>          +#+  +:+       +#+         #
#                                                 +#+#+#+#+#+   +#+            #
#    Created: 2026/02/22 10:37:06 by brturcio          #+#    #+#              #
#    Updated: 2026/02/23 10:47:54 by brturcio         ###   ########.fr        #
#                                                                              #
# **************************************************************************** #

NAME		:= span
CC			:= c++
CFLAGS		:= -Wall -Wextra -Werror -std=c++98

DIR_SRCS	:= sources/
DIR_OBJS	:= objs/

SOURCES		:= main.cpp Span.cpp
OBJECTS		:= $(addprefix $(DIR_OBJS), $(SOURCES:.cpp=.o))

INCLUDES	:= -Iincludes

GREEN		:= \033[0;32m
RESET		:= \033[0m

all: $(NAME)

$(DIR_OBJS)%.o: $(DIR_SRCS)%.cpp
	@mkdir -p $(DIR_OBJS)
	@$(CC) $(CFLAGS) $(INCLUDES) -c $< -o $@

$(NAME): $(OBJECTS)
	@$(CC) $(CFLAGS) $(OBJECTS) -o $(NAME)
	@echo "$(GREEN)✔ $(NAME) Created Successfully!$(RESET)"

clean:
	@rm -rf $(DIR_OBJS)
	@echo "$(GREEN)✔ Objects Cleaned$(RESET)"

fclean: clean
	@rm -rf $(NAME)
	@echo "$(GREEN)✔ Excecutable Cleaned$(RESET)"

re: fclean all

.PHONY: all clean fclean re
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   Span.cpp                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: brturcio <brturcio@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2026/02/23 10:49:02 by brturcio          #+#    #+#             */
/*   Updated: 2026/02/24 12:17:48 by brturcio         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "Span.hpp"
#include <algorithm>
#include <cstdlib>

/* =========================== default constructor ========================== */
Span::Span(void) :
	_vec(0),
	_size(0)
{}

/* ======================== parameter constructor =========================== */
Span::Span(unsigned int n) :
	_vec(0),
	_size(n)
{}

/* =========================== copy constructor ============================= */
Span::Span(const Span & copy)
{
	_vec = copy._vec;
	_size = copy._size;
}

/* ==================== copy assignment operator (=) ======================== */
Span & Span::operator=(const Span & other)
{
	if (this != &other) {
		_vec = other._vec;
		_size = other._size;
	}
	return (*this);
}

/* ================================ destructor ============================== */
Span::~Span(void)
{}

/* ================================= getters ================================ */
std::vector<int>&	Span::getVec(void)
{
	return (_vec);
}

/* ============================ public methods ============================== */
void	Span::addNumber(int newN)
{
	if (_vec.size() >= _size)
		throw FullVectorException();
	_vec.push_back(newN);
}

int	Span::longestSpan(void)
{
	int	max = 0;

	if (_vec.size() <= 1)
		throw InsufficientNumbersException();
	std::vector<int>	tmp = _vec;
	std::sort(tmp.begin(), tmp.end());
	max = tmp[tmp.size() - 1] - tmp[0];
	return (max);
}

int	Span::shortestSpan(void)
{
	int	min = 0;

	if (_vec.size() <= 1)
		throw InsufficientNumbersException();
	std::vector<int>	tmp = _vec;
	std::sort(tmp.begin(), tmp.end());
	min = tmp[1] - tmp[0];
	for (unsigned int i = 2; i < tmp.size(); i++) {
		if (tmp[i] - tmp[i - 1] < min)
			min = tmp[i] - tmp[i - 1];
	}
	return (min);
}

/* ============================== exceptions ================================ */
const char * Span::FullVectorException::what() const throw()
{
	return ("Cannot add number: span is already full.");
}

const char * Span::InsufficientNumbersException::what() const throw()
{
	return ("Insufficient elements to calculate span.");
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   main.cpp                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: brturcio <brturcio@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2026/02/22 10:47:12 by brturcio          #+#    #+#             */
/*   Updated: 2026/02/24 13:22:53 by brturcio         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "Span.hpp"
#include <exception>
#include <iostream>
#include <list>

template <typename T>
void	printArray(T & tabl)
{
	for (unsigned int i = 0; i < tabl.size(); i++) {
		std::cout << tabl[i];
		if (i < tabl.size() - 1)
			std::cout << ", ";
	}
	std::cout << std::endl;
}

int	main(void)
{
	std::list<int>	l;
	l.push_back(10);
	l.push_back(1);
	l.push_back(5);
	l.push_back(90);
	l.push_back(50);
	l.push_back(12);

	{
		std::cout << "============================ Test subject ============================\n\n";		
		try {
			Span sp = Span(5);
			
			sp.addNumber(6);
			sp.addNumber(3);
			sp.addNumber(17);
			sp.addNumber(9);
			sp.addNumber(11);
			printArray(sp.getVec());
			std::cout << INF << sp.shortestSpan() << RST << std::endl;
			std::cout << SUC << sp.longestSpan() << RST << std::endl;
		} catch (std::exception & e){
			std::cout << ERR << e.what() << SUC << std::endl;
		}
	}
	{
		std::cout << "\n============================ insertRange ============================\n\n";		
		try {
			Span	sp = Span(6);

			sp.insertRange(l.begin(), l.end());
			printArray(sp.getVec());
			std::cout << INF << sp.shortestSpan() << RST << std::endl;
			std::cout << SUC << sp.longestSpan() << RST << std::endl;
		} catch (std::exception & e) {
			std::cout << ERR << e.what() << SUC << std::endl;
		}
	}
	{
		std::cout << RST << "\n============================ Full vector ============================\n\n";		
		try {
			Span	sp = Span(2);

			sp.insertRange(l.begin(), l.end());
			std::cout << INF << sp.shortestSpan() << RST << std::endl;
			std::cout << SUC << sp.longestSpan() << RST << std::endl;
			printArray(sp.getVec());
		} catch (std::exception & e) {
			std::cout << ERR << e.what() << SUC << std::endl;
		}
	}
	{
		std::cout << RST << "\n============================ Only one value ============================\n\n";		
		try {
			Span	sp = Span(1);
			
			sp.addNumber(2);
			std::cout << INF << sp.shortestSpan() << RST << std::endl;
			std::cout << SUC << sp.longestSpan() << RST << std::endl;
			printArray(sp.getVec());
		} catch (std::exception & e) {
			std::cout << ERR << e.what() << SUC << std::endl;
		}
	}
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   Span.hpp                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: brturcio <brturcio@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2026/02/23 10:49:05 by brturcio          #+#    #+#             */
/*   Updated: 2026/02/24 12:28:07 by brturcio         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef SPAN_HPP
# define SPAN_HPP

#include <exception>
#include <iterator>
#include <vector>

# define RST "\033[0m"
# define ERR "\033[0;91m"
# define WRN "\033[0;93m"
# define SUC "\033[0;92m"
# define INF "\033[0;96m"
# define INP "\033[0;94m"

class Span
{
private:
	std::vector<int>	_vec;
	unsigned int		_size;

	Span(void);
public:
	Span(unsigned int n);
	Span(const Span & copy);
	Span & operator=(const Span & other);
	~Span(void);

	template <typename T>
	void	insertRange(T begin, T end)
	{
		size_t	distance = static_cast<size_t>(std::distance(begin, end)) ;

		if (_vec.size() + distance > _size)
			throw FullVectorException();
		_vec.insert(_vec.end(), begin, end);
	}
	void	addNumber(int newN);
	int		shortestSpan();
	int		longestSpan();
	
	std::vector<int> &	getVec(void);
	
class FullVectorException : public std::exception
{
	virtual const char * what() const throw();
};

class InsufficientNumbersException : public std::exception
{
	virtual const char * what() const throw();
};
};

#endif
